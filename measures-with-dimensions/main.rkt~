#lang racket

;; For:
;; (require "documents/drracket/stuff/dimmensional-analysis/main.rkt")
;;

(define-namespace-anchor current-namespace-anchor_0)
(current-namespace (namespace-anchor->namespace current-namespace-anchor_0))

(provide (except-out (all-defined-out)
                     logbase
                     10^
                     n* n/
                     )
         (except-out (all-from-out racket)
                     =
                     ;+ -
                     * /
                     expt
                     sqr
                     sqrt
                     )
         (rename-out [nwu= =]
                     [nwu* *]
                     [nwu/ /]
                     [nwu+ +]
                     [nwu- -]
                     [nwuexpt expt]
                     [nwusqr sqr]
                     [nwusqrt sqrt]
                     )
         i j k
         )

(require (prefix-in racket: racket))
(require "../my-test-engine/my-racket-gui.rkt")
(require (only-in lang/htdp-intermediate-lambda =~))
(require (only-in "../non-algebra/vectors.rkt"
                  [add +]
                  [subtract -]
                  ;[multiply *]
                  ;[divide /]
                  i j k
                  ))
(require hash-lambda/misc/syntax-to-string)
(require (only-in "../lang/alex.rkt"
                  define/contract*))
(define (symbol->string x)
  (if (symbol? x)
      (racket:symbol->string x)
      (~a x)))

(define exact
  (case-lambda 
    [(n) (cond [(number-without-unit? n)
                (racket:inexact->exact n)]
               [(number-with-unit? n)
                (struct-copy number-with-unit n 
                             [number 
                              (exact (number-with-unit-number n))])]
               [(vector? n)
                (for/vector ([item (in-vector n)])
                  (exact item))]
               [(list? n)
                (for/list ([item (in-list n)])
                  (exact item))]
               [else
                n])]
    [args (apply values (map exact args))]))
(define inexact
  (case-lambda
    [(n) (cond [(number-without-unit? n)
                (racket:exact->inexact n)]
               [(number-with-unit? n)
                (struct-copy number-with-unit n 
                             [number 
                              (inexact (number-with-unit-number n))])]
               [(vector? n)
                (for/vector ([item n])
                  (inexact item))]
               [(list? n)
                (for/list ([item n])
                  (inexact item))]
               [else
                n])]
    [args (apply values (map inexact args))]))

(define (number-without-unit? n)
  (number? n))

(define (logbase b x)
  (/ (log x)
     (log b)))

(define (10^ x)
  (expt 10 x))

(define really-close-to-tau  ;tau, up to the Feynman point, from http://tauday.com/tau-digits
  #e6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341359642961730265646132941876892191011644634507188162569622349005682054038770422111192892458979098607639288576219513318668922569512964675735663305424038182912971338469206972209086532964267872145204982825474491740132126311763497630418419256585081834307287357851807200226610610976409330427682939038830232188661145407315191839061843722347638652235862102370961489247599254991347037715054497824558763660238982596673467248813132861720427898927904494743814043597218874055410784343525863535047693496369353388102640011362542905271216555715426855155792183472743574429368818024499068602930991707421015845593785178470840399122242580439217280688363196272595495426199210374144227
  )
(define really-close-to-pi   ;pi,  up to the Feynman point, from http://en.wikipedia.org/wiki/Feynman_point
  #e3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721135
  )
(define really-close-to-eta  ;eta, up to the Feynman point
  #e1.570796326794896619231321691639751442098584699687552910487472296153908203143104499314017412671058533991074043256641153323546922304775291115862679704064240558725142051350969260552779822311474477465190982214405487832966723064237824116893391582635600954572824283461730174305227163324106696803630124570636862293503303157794087440760460481414627045857682183946295180005665265274410233260692073475970755804716528635182879795976546093058690966305896552559274037231189981374783675942876362445613969091505974564916836681220328321543010697473197612368595351089930471851385269608588146588376192337409233834702566000284063572631780413892885671378894804586818589360734220450612476715073274792685525396139844629461771009978056064510980432017209079906814887385654980259353605675
  )
(check-expect (racket:equal? (exact->inexact really-close-to-tau)
                             (* 2 racket:pi))
              true)
(check-expect (racket:equal? (exact->inexact really-close-to-pi)
                             racket:pi)
              true)
(check-expect (racket:equal? (exact->inexact really-close-to-eta)
                             (/ racket:pi 2))
              true)

(define tau really-close-to-tau)
(define pi  really-close-to-pi)
(define eta really-close-to-eta)
(define really-close-to-2pi (* 2 really-close-to-pi))
(define 2pi really-close-to-2pi)
(define really-close-to-2*pi (* 2 really-close-to-pi))
(define 2*pi really-close-to-2*pi)

(define even-closer-to-pi
  (string->number
   (string-append
    "#e"
    "3."
    "1415926535" "8979323846" "2643383279" "5028841971" "6939937510" "5820974944" "5923078164" "0628620899" "8628034825" "3421170679" 
    "8214808651" "3282306647" "0938446095" "5058223172" "5359408128" "4811174502" "8410270193" "8521105559" "6446229489" "5493038196"
    "4428810975" "6659334461" "2847564823" "3786783165" "2712019091" "4564856692" "3460348610" "4543266482" "1339360726" "0249141273"
    "7245870066" "0631558817" "4881520920" "9628292540" "9171536436" "7892590360" "0113305305" "4882046652" "1384146951" "9415116094"
    "3305727036" "5759591953" "0921861173" "8193261179" "3105118548" "0744623799" "6274956735" "1885752724" "8912279381" "8301194912"
    "9833673362" "4406566430" "8602139494" "6395224737" "1907021798" "6094370277" "0539217176" "2931767523" "8467481846" "7669405132"
    "0005681271" "4526356082" "7785771342" "7577896091" "7363717872" "1468440901" "2249534301" "4654958537" "1050792279" "6892589235"
    "4201995611" "2129021960" "8640344181" "5981362977" "4771309960" "5187072113" "4999999837" "2978049951" "0597317328" "1609631859"
    "5024459455" "3469083026" "4252230825" "3344685035" "2619311881" "7101000313" "7838752886" "5875332083" "8142061717" "7669147303"
    "5982534904" "2875546873" "1159562863" "8823537875" "9375195778" "1857780532" "1712268066" "1300192787" "6611195909" "2164201989"
    )))





(define n*
  (local [(define (scalar? x)
            (number? x))
          (define (scalar*vector s v)
            (vector-map (curry * s) v))]
    (lambda args
      (cond [(andmap scalar? args)
             (apply * args)]
            [(= 0 (length (filter vector? args)))
             (when (not (andmap number? args))
               (displayln (apply string-append 
                                 (cons "warning: n*: not all arguments are numbers. /n args:"
                                       (for/list ([arg args])
                                         (string-append " "(~v arg)""))))))
             (apply * args)]
            [(= 1 (length (filter vector? args)))
             (scalar*vector (apply * (filter-not vector? args))
                            (first (filter vector? args)))]
            [else
             (error "*: expects no more than one vector as an operand")]))))

(define n/
  (local [(define (scalar? x)
            (number? x))
          (define (vector*scalar v s)
            (vector-map (curry * s) v))]
    (case-lambda
      [() 1]
      [(arg) (/ arg)]
      [args
       (cond [(andmap scalar? args)
              (apply / args)]
             [(and (vector? (first args))
                   (andmap scalar? (rest args)))
              (vector*scalar (first args)
                             (/ (apply * (rest args))))]
             [else
              (when (not (andmap number? args))
                (displayln (apply string-append 
                                  (cons "warning: n*: not all arguments are numbers. /n args:"
                                        (for/list ([arg args])
                                          (string-append " "(~v arg)""))))))
              (error "/: no vectors allowed in the denominator")])])))

(define average
  (lambda args
    (nwu/ (apply nwu+ args)
          (length args))))

(define (dot a b)
  (apply nwu+
         (for/list ([a-i a]
                    [b-i b])
           (nwu* a-i b-i))))

(define (vsqr v)
  (define v->nwu (any->number-with-unit v))
  (define v-number (nwu-number v->nwu))
  (cond [(for/and ([item v-number])
           (number-without-unit? item))
         (define v-unit (nwu-unit v->nwu))
         (number-with-unit (for/sum ([v-i v-number])
                             (sqr v-i))
                           (u* v-unit v-unit))]
        [else
         (error "vector-with-unit: not all components have the same unit-dimension, given:" v)]))
(define (vector-magnitude v)
  (define v->nwu (any->number-with-unit v))
  (define v-number (nwu-number v->nwu))
  (cond [(for/and ([item v-number])
           (number-without-unit? item))
         (number-with-unit (sqrt (for/sum ([v-i v-number])
                                   (sqr v-i)))
                           (nwu-unit v->nwu))]
        [else
         (error "vector-with-unit: not all components have the same unit-dimension, given:" v)]))



(define my-equal?
  (lambda args
    (cond [(empty? args)
           (error "my-equal?: expects 2 or more arguments, given" (length args))]
          [else
           (define fst (first args))
           (define (my-equal?--2 a b)
             (define (both pred?)
               (and (pred? a)
                    (pred? b)))
             (cond [(both number?)
                    (= a b)]
                   [(both struct?)
                    (equal?/recur (struct->vector a)
                                  (struct->vector b)
                                  my-equal?--2)]
                   [else
                    (equal?/recur a b my-equal?--2)]))
           (define (=first? a)
             (my-equal?--2 fst a))
           (andmap =first? (rest args))])))



(define (system=SI? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(metric SI mks cgs)))
(define (system=US? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(US British)))

(define current-measurement-system 
  (make-parameter 'SI
                  (lambda (new-system)
                    (cond [(system=SI? new-system)
                           'SI]
                          [(system=US? new-system)
                           'US]
                          [else 
                           (error "current-measurement-system: expected a valid system of units, given:" new-system)]))))



(define (angle-system=radians? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(radians radian radians-without-pi radians-without-tau)))
(define (angle-system=radians-with-pi? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(radians-with-pi radian-with-pi rad-with-pi)))
(define (angle-system=radians-with-2pi? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(radians-with-2pi
           radian-with-2pi
           rad-with-2pi
           radians-with-2-pi
           radian-with-2-pi
           rad-with-2-pi
           radians-with-2*pi
           radian-with-2*pi
           rad-with-2*pi)))
(define (angle-system=radians-with-tau? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(radians-with-tau radian-with-tau rad-with-tau)))
(define (angle-system=radians-with-eta? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(radians-with-eta radian-with-eta rad-with-eta)))
(define (angle-system=turns? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(turns turn revolutions revolution rev)))
(define (angle-system=degrees? system)
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (define |(string-downcase (any->string system))|
    (string-downcase (any->string system)))
  (findf (lambda (item)
           (equal? |(string-downcase (any->string system))|
                   (string-downcase (any->string item)))) 
         '(degrees degree deg)))

(define current-angle-measurement-system 
  (make-parameter 'radians-with-2pi
                  (lambda (new-system)
                    (cond [(angle-system=radians? new-system)
                           'radians]
                          [(angle-system=radians-with-pi? new-system)
                           'radians-with-pi]
                          [(angle-system=radians-with-2pi? new-system)
                           'radians-with-2pi]
                          [(angle-system=radians-with-tau? new-system)
                           'radians-with-tau]
                          [(angle-system=radians-with-eta? new-system)
                           'radians-with-eta]
                          [(angle-system=turns? new-system)
                           'turns]
                          [(angle-system=degrees? new-system)
                           'degrees]
                          [else 
                           (error "current-angle-measurement-system: expected a valid angle measurement system, given:" new-system)]))))



(define (struct-ref expr i)
  (vector-ref (struct->vector expr) (add1 i)))

(define-syntax arb-art-struct
  (syntax-rules ()
    [(arb-art-struct name name? name-ref)
     (begin (define name
              (lambda args
                (local [(define-values (struct:name name name? name-ref name-set!)
                          (make-struct-type 'name #f (length args) 0 #f empty (make-inspector (current-inspector))))]
                  (apply name args))))
            (define (name? expr)
              (and (struct? expr)
                   (equal? (string->symbol (string-append "struct:"(symbol->string 'name))) (vector-ref (struct->vector expr) 0))))
            (define (name-ref expr i) 
              (cond [(name? expr)
                     (struct-ref expr i)]
                    [else
                     (error (string-append(symbol->string 'name-ref)": expected a "(symbol->string 'name)" as the 1st argument, given:") expr)])))]))
























#;(struct named-dimension (name dimension)
    #:transparent
    #:methods gen:custom-write
    [(define (write-proc expr out quote-depth)
       (cond [(or (equal? 0 quote-depth)
                  (equal? 1 quote-depth))
              (print-named-dimension expr
                                     out quote-depth)]
             [else
              (print-named-dimension expr
                                     out)]))]
    )
#;(define (dimension-rename d n)
    (cond [(named-dimension? d)
           (struct-copy named-dimension d
                        [name n])]
          [else
           (named-dimension n d)]))

(struct dimension:dimensionless () #:transparent)  ; a dimensionless number
(struct dimension:length () #:transparent)         ; a decimeter
(struct dimension:mass () #:transparent)           ; a kilogram
(struct dimension:time () #:transparent)           ; a second
(struct dimension:temperature () #:transparent)    ; a kelvin

(define (dimension? expr)
  (or (dimension:dimensionless? expr)
      (dimension:length? expr)
      (dimension:mass? expr)
      (dimension:time? expr)
      (dimension:temperature? expr)
      (dimension-product? expr)
      (dimension-quotient? expr)
      (dimension-expt? expr)
      ))
(define (atomic-dimension? expr)
  (and (dimension? expr)
       (or (dimension:dimensionless? expr)
           (dimension:length? expr)
           (dimension:mass? expr)
           (dimension:time? expr)
           (dimension:temperature? expr)
           (and (dimension-expt? expr)
                (= -1 (dimension-expt-exponent expr))
                (atomic-dimension? (dimension-expt-base expr))
                (not (dimension:dimensionless? (dimension-expt-base expr)))
                (not (dimension-expt? (dimension-expt-base expr)))))))
(define (dimensionless? x)
  (dimension=? (dimension:dimensionless)
               x))

(arb-art-struct dimension-product dimension-product? dimension-product-ref)
(arb-art-struct dimension-quotient dimension-quotient? dimension-quotient-ref)
(struct dimension-expt (base exponent) #:transparent)





;; dimension=? : (Dimension ... -> Boolean)
;; produce true if all of the given dimensions are equal, normalizing them first
(check-expect (dimension=? (dimension:length) (dimension:length))
              true)

(define dimension=?
  (lambda args
    (cond [(empty? args)
           (error "dimension=?: expects 2 or more arguments, given 0")]
          [else
           (define fst (normalize-dimension (first args)))
           (define (my-equal?--2 a b)
             (define (both pred?)
               (and (pred? a)
                    (pred? b)))
             (cond [(both number?)
                    (= a b)]
                   [(both struct?)
                    (equal?/recur (struct->vector a)
                                  (struct->vector b)
                                  my-equal?--2)]
                   [else
                    (equal?/recur a b my-equal?--2)]))
           (define (=first? a)
             (my-equal?--2 fst (normalize-dimension a)))
           (andmap =first? (rest args))])))

;; normalize-dimension : (Dimension -> Dimension)
;; rewrite the dimension as a product of dimensions or inverse dimensions, and cancel them out
(check-expect (normalize-dimension (dimension-quotient (dimension:length) (dimension:time)))
              (sort-dimension-product (dimension-product (dimension:length) (dimension-expt (dimension:time) -1))))
(check-expect (normalize-dimension (dimension-expt (dimension-product (dimension:acceleration) (dimension:length)) 1/2))
              (normalize-dimension (dimension:velocity)))

(define (normalize-dimension d)
  (cond [(empty? (dimension-product->list d))
         (dimension:dimensionless)]
        [(and (dimension-expt? d)
              (dimensionless? (dimension-expt-base d)))
         (dimension:dimensionless)]
        [(atomic-dimension? d)
         d]
        [(and (dimension-product? d)
              (= 1 (length (dimension-product->list d))))
         (normalize-dimension
          (dimension-product-ref d 0))]
        [(and (dimension-expt? d)
              (dimension-expt? (dimension-expt-base d)))
         (define b (dimension-expt-base d))
         (normalize-dimension
          (dimension-expt (dimension-expt-base b)
                          (n* (dimension-expt-exponent d)
                              (dimension-expt-exponent b))))]
        [(dimension-product? d)
         (define (maybe-dimension-equal? a b)
           (or (my-equal? a b)
               (and (dimension? a)
                    (dimension? b)
                    (dimension=? a b))))
         (define flattened
           (flatten-dimension-product
            (list->dimension-product
             (filter-not dimensionless?
                         (map normalize-dimension
                              (rest (vector->list (struct->vector d))))))))
         (cond [(empty? (dimension-product->list flattened))
                (dimension:dimensionless)]
               [(= 1 (length (dimension-product->list flattened)))
                (normalize-dimension
                 (dimension-product-ref flattened 0))]
               [(and (findf dimension-expt? (dimension-product->list flattened))
                     (= -1 (dimension-expt-exponent (findf dimension-expt? (dimension-product->list flattened))))
                     (findf (lambda (item)
                              (maybe-dimension-equal? item (dimension-expt-base (findf dimension-expt? (dimension-product->list flattened)))))
                            (dimension-product->list flattened)))
                (normalize-dimension
                 (list->dimension-product
                  (remove (findf dimension-expt? (dimension-product->list flattened))
                          (remove (dimension-expt-base (findf dimension-expt? (dimension-product->list flattened)))
                                  (dimension-product->list flattened)
                                  maybe-dimension-equal?)
                          maybe-dimension-equal?)))]
               [else
                (sort-dimension-product
                 (list->dimension-product
                  (cons (first (dimension-product->list flattened))
                        (filter-not dimensionless?
                                    (dimension-product->list
                                     (normalize-dimension
                                      (list->dimension-product
                                       (rest (dimension-product->list flattened)))))))))])]
        [(dimension-quotient? d)
         (normalize-dimension
          (dimension-quotient->dimension-product d))]
        [(and (dimension-expt? d)
              (number? (dimension-expt-exponent d))
              (not (integer? (dimension-expt-exponent d))))
         (define b (dimension-expt-base d))
         (define e (dimension-expt-exponent d))
         (cond [(dimension-expt? b)
                (cond [(integer? (n* e (dimension-expt-exponent b)))
                       (normalize-dimension
                        (dimension-expt (dimension-expt-base b)
                                        (n* e (dimension-expt-exponent b))))]
                      [else
                       #;(error "dimensions with non-integer exponents are not allowed")
                       d])]
               [else
                (define nb (normalize-dimension b))
                (cond [(dimension-product? nb)
                       (define lod (dimension-product->list nb))
                       (cond [(and (integer? (n* e (length lod)))
                                   (apply dimension=? lod))
                              (normalize-dimension
                               (list->dimension-product
                                (build-list (n* e (length lod))
                                            (const (first lod)))))]
                             [(and (integer? (* e (length lod)))
                                   (integer? (/ e))
                                   (for/and ([n (build-list (/ e) identity)])
                                     (apply dimension=?
                                            (build-list (* e (length lod))
                                                        (lambda (i)
                                                          (list-ref lod
                                                                    (+ (* n
                                                                          (* e (length lod)))
                                                                       i)))
                                                        ))))
                              (normalize-dimension
                               (list->dimension-product
                                (build-list (n* e (length lod))
                                            (lambda (i)
                                              (list-ref lod
                                                        (* i (/ e))))
                                            )))]
                             [(and (integer? (* e (length lod)))
                                   (not (integer? (/ e))))
                              (normalize-dimension
                               (dimension-expt (normalize-dimension
                                                (dimension-expt nb
                                                                (denominator e)))
                                               (numerator e)))]
                             [else
                              #;(error "dimensions with non-integer exponents are not allowed")
                              d])]
                      [else
                       #;(error "dimensions with non-integer exponents are not allowed")
                       d])])]
        [(and (dimension-expt? d)
              (not (= -1 (dimension-expt-exponent d))))
         (normalize-dimension
          (list->dimension-product
           (build-list (inexact->exact (abs (dimension-expt-exponent d)))
                       (const (if (not (negative? (dimension-expt-exponent d)))
                                  (dimension-expt-base d)
                                  (dimension-expt (dimension-expt-base d) -1))))))]
        [(and (dimension-expt? d)
              (= -1 (dimension-expt-exponent d))
              (dimension-expt? (dimension-expt-base d))
              (= -1 (dimension-expt-exponent (dimension-expt-base d))))
         (normalize-dimension
          (dimension-expt-base (dimension-expt-base d)))]
        [(and (dimension-expt? d)
              (= -1 (dimension-expt-exponent d))
              (not (atomic-dimension? d)))
         (list->dimension-product
          (map (lambda (item)
                 (dimension-expt item -1))
               (dimension-product->list (normalize-dimension (dimension-expt-base d)))))]
        [else
         d]))

(define (dimension-product->list dp)
  (cond [(dimension-product? dp)
         (rest (vector->list (struct->vector dp)))]
        [else
         (list dp)]))
(define (list->dimension-product lox)
  (apply dimension-product lox))

(define (dimension-quotient->dimension-product expr)
  (cond [(= 1 (length (rest (vector->list (struct->vector expr)))))
         (dimension-expt (dimension-quotient-ref expr 0) -1)]
        [else 
         (list->dimension-product
          (cons (dimension-quotient-ref expr 0)
                (map (lambda (item)
                       (dimension-expt item -1))
                     (rest (rest (vector->list (struct->vector expr)))))))]))

(define (sort-dimension-product dp)
  (local [(define (d<? a b)
            (string<? (~v a)
                      (~v b)))]
    (list->dimension-product
     (sort (dimension-product->list dp)
           d<?))))


;; flatten-dimension-product : (dimension-product -> dimension-product)
;; flatten a dimension-product
(check-expect (flatten-dimension-product (dimension-product))
              (dimension-product))
(check-expect (flatten-dimension-product (dimension-product (dimension:mass)))
              (dimension-product (dimension:mass)))
(check-expect (flatten-dimension-product (dimension-product (dimension:mass)
                                                            (dimension-product (dimension:length)
                                                                               (dimension-expt (dimension:time) -1))))
              (dimension-product (dimension:mass)
                                 (dimension:length)
                                 (dimension-expt (dimension:time) -1)))

(define (flatten-dimension-product dp)
  (cond [(empty? (dimension-product->list dp))
         (dimension-product)]
        [(dimension-product? dp)
         (list->dimension-product
          (remove* (list (dimension:dimensionless))
                   (append (dimension-product->list 
                            (flatten-dimension-product
                             (first (dimension-product->list dp))))
                           (dimension-product->list 
                            (flatten-dimension-product
                             (list->dimension-product
                              (rest (dimension-product->list dp))))))
                   my-equal?))]
        [else
         dp]))



;; print-named-dimension : (Any [OutputPort (current-output-port)] [(or/c 0 1) 0] -> Void)
;; print a dimension
;; !!!
#;(define (print-named-dimension expr [out (current-output-port)] [quote-depth 0])
    (define (any->string thing)
      (cond [(string? thing)
             thing]
            [(symbol? thing)
             (symbol->string thing)]
            [else (~v thing)]))
    (cond [(and (named-dimension? expr)
                (not (false? (named-dimension-name expr)))
                (not (equal? "" (named-dimension-name expr)))
                (not (equal? '|| (named-dimension-name expr))))
           (display (string-append
                     (if (number? quote-depth)
                         (apply string-append (build-list quote-depth (const ",")))
                         "")
                     (string-append "(dimension:"(any->string (named-dimension-name expr))")"))
                    out)]
          [(and (named-dimension? expr)
                (or (false? (named-dimension-name expr))
                    (equal? "" (named-dimension-name expr))
                    (equal? '|| (named-dimension-name expr)))
                (not (false? (find-dimension-name expr))))
           (define name (find-dimension-name expr))
           (display (string-append
                     (if (number? quote-depth)
                         (apply string-append (build-list quote-depth (const ",")))
                         "")
                     (string-append "(dimension:"(any->string name)")"))
                    out)]
          [(named-dimension? expr)
           (print (named-dimension-dimension expr)
                  out quote-depth)]
          [else
           (print expr out quote-depth)]))



(define (dimension:area) |(dimension:area)|)
(define |(dimension:area)|
  (dimension-product (dimension:length)
                     (dimension:length)))

(define (dimension:volume) |(dimension:volume)|)
(define |(dimension:volume)|
  (dimension-product (dimension:length)
                     (dimension:length)
                     (dimension:length)))

(define (dimension:density) |(dimension:density)|)
(define |(dimension:density)|
  (normalize-dimension
   (dimension-quotient (dimension:mass)
                       (dimension:volume))))

(define (dimension:velocity) |(dimension:velocity)|)
(define |(dimension:velocity)|
  (normalize-dimension
   (dimension-quotient (dimension:length)
                       (dimension:time))))

(define (dimension:acceleration) |(dimension:acceleration)|)
(define |(dimension:acceleration)|
  (normalize-dimension
   (dimension-quotient (dimension:velocity)
                       (dimension:time))))

(define (dimension:force) |(dimension:force)|)
(define |(dimension:force)|
  (normalize-dimension
   (dimension-product (dimension:mass)
                      (dimension:acceleration))))

(define (dimension:momentum) |(dimension:momentum)|)
(define |(dimension:momentum)|
  (normalize-dimension
   (dimension-product (dimension:mass)
                      (dimension:velocity))))

(define (dimension:energy) |(dimension:energy)|)
(define (dimension:work) |(dimension:energy)|)
(define |(dimension:energy)|
  (normalize-dimension
   (dimension-product (dimension:force)
                      (dimension:length))))

(define (dimension:power) |(dimension:power)|)
(define |(dimension:power)|
  (normalize-dimension
   (dimension-quotient (dimension:work)
                       (dimension:time))))

(define (dimension:pressure) |(dimension:pressure)|)
(define |(dimension:pressure)|
  (normalize-dimension
   (dimension-quotient (dimension:force)
                       (dimension:area))))

(define ALL-DIMENSIONS
  (list (dimension:dimensionless)
        (dimension:length)
        (dimension:mass)
        (dimension:time)
        (dimension:temperature)
        (dimension:area)
        (dimension:volume)
        (dimension:density)
        (dimension:velocity)
        (dimension:acceleration)
        (dimension:force)
        (dimension:momentum)
        (dimension:energy)
        (dimension:power)
        (dimension:pressure)
        ))





















(struct unit (name scalar dimension)
  #:transparent
  #:methods gen:custom-write
  [(define (write-proc expr out quote-depth)
     (cond [(or (equal? 0 quote-depth)
                (equal? 1 quote-depth))
            (print-unit expr out quote-depth)]
           [else
            (print-unit expr out)]))]
  )
(define (unit-name_0 a)
  (unit-name (any->unit a)))
(define (unit-scalar_0 a)
  (unit-scalar (any->unit a)))
(define (unit-dimension_0 a)
  (unit-dimension (any->unit a)))
(define (any->unit expr)
  (cond [(dimension? expr)
         (unit #f 1 expr)]
        [(unit? expr)
         expr]
        [(number-with-unit? expr)
         (unit #f 
               (n* (nwu-number expr)
                   (unit-scalar_0 
                    (nwu-unit expr)))
               (nwu-dimension expr))]
        [(number-without-unit? expr)
         (unit #f
               expr
               (dimension:dimensionless))]
        [(and (vector? expr)
              (< 1 (vector-length expr))
              (apply dimension=?
                     (map nwu-dimension
                          (vector->list expr))))
         (define v-unit
           (nwu-unit (vector-ref expr 0)))
         (define v-unit-scalar
           (unit-scalar v-unit))
         (define v-unit-dimension
           (unit-dimension v-unit))
         (define v-numbers
           (vector-map (lambda (item)
                         (nwu-number (convert item v-unit)))
                       expr))
         (when (and (vector? v-numbers)
                    (not (andmap number-without-unit? (vector->list v-numbers))))
           (displayln (string-append "warning: "
                                     "vector-with-unit: nwu-number may not be a (vectorof number-without-unit?), "
                                     "in: "(~v v-numbers))))
         (unit #f
               (n* v-numbers
                   v-unit-scalar)
               v-unit-dimension)]
        [else
         (when (not (or (number? expr)
                        (vector? expr)))
           (displayln (string-append "warning: "
                                     "number-with-unit: nwu-number may not be a number or a vector, "
                                     "in: "(~v expr))))
         (when (and (vector? expr)
                    (not (andmap number-without-unit? (vector->list expr))))
           (displayln (string-append "warning: "
                                     "vector-with-unit: nwu-number may not be a (vectorof number-without-unit?), "
                                     "in: "(~v expr))))
         (unit #f expr (dimension:dimensionless))]))


(define unit=?
  (lambda args
    (cond [(empty? args)
           (error "unit=?: expects 2 or more arguments, given 0")]
          [else
           (define fst (first args))
           (define fst-scalar (unit-scalar_0 fst))
           (define fst-dimension (normalize-dimension (unit-dimension_0 fst)))
           (define (my-equal?--2 a b)
             (define (both pred?)
               (and (pred? a)
                    (pred? b)))
             (cond [(both number?)
                    (= a b)]
                   [(both struct?)
                    (equal?/recur (struct->vector a)
                                  (struct->vector b)
                                  my-equal?--2)]
                   [else
                    (equal?/recur a b my-equal?--2)]))
           (define (=first? u)
             (and (my-equal?--2 fst-scalar (unit-scalar_0 u))
                  (my-equal?--2 fst-dimension (normalize-dimension (unit-dimension_0 u)))))
           (andmap =first? (rest args))])))

(define named-unit=?
  (lambda args
    (cond [(empty? args)
           (error "unit=?: expects 2 or more arguments, given 0")]
          [else
           (define fst (first args))
           (define fst-name (unit-name_0 fst))
           (define fst-scalar (unit-scalar_0 fst))
           (define fst-dimension (normalize-dimension (unit-dimension_0 fst)))
           (define (my-equal?--2 a b)
             (define (both pred?)
               (and (pred? a)
                    (pred? b)))
             (cond [(both number?)
                    (= a b)]
                   [(both struct?)
                    (equal?/recur (struct->vector a)
                                  (struct->vector b)
                                  my-equal?--2)]
                   [else
                    (equal?/recur a b my-equal?--2)]))
           (define (=first? u)
             (and (my-equal?--2 fst-name (unit-name_0 u))
                  (my-equal?--2 fst-scalar (unit-scalar_0 u))
                  (my-equal?--2 fst-dimension (normalize-dimension (unit-dimension_0 u)))))
           (andmap =first? (rest args))])))

(define (unit-rename u n)
  (cond [(unit? u)
         (struct-copy unit u
                      [name n])]
        [(unit? n)
         (struct-copy unit n
                      [name u])]
        [else
         (error "unit-rename: expects a unit as it's first argument, given" u)]))

(define-syntax define-unit
  (syntax-rules ()
    [(define-unit (u) expr)
     (define (u)
       (unit-rename (any->unit expr)
                    'u))]
    [(define-unit (u) expr1 ... expr)
     (define (u)
       expr1 ...
       (unit-rename (any->unit expr)
                    'u))]
    [(define-unit (u a ...) expr1 ... expr)
     (define (u a ...)
       expr1 ...
       (unit-rename (any->unit expr)
                    (string->symbol
                     (apply string-append 
                            (cons (symbol->string 'u)
                                  (list (string-append " "(~v a))
                                        ...))))))]
    [(define-unit u expr)
     (define u
       (procedure-rename
        (procedure-reduce-arity 
         (lambda args
           (unit-rename (any->unit (apply expr args))
                        (string->symbol
                         (apply string-append 
                                (cons (symbol->string 'u)
                                      (for/list ([a args])
                                        (string-append " "(~v a))))))))
         (procedure-arity expr))
        'u))]))

(define u*
  (lambda args
    (unit #f 
          (apply n* 
                 (map unit-scalar_0 args))
          (normalize-dimension
           (apply dimension-product
                  (map unit-dimension_0 args))))))

(define u/
  (lambda args
    (unit #f 
          (apply n/
                 (map unit-scalar_0 args))
          (normalize-dimension
           (apply dimension-quotient
                  (map unit-dimension_0 args))))))

(define u+
  (lambda args
    (cond [(empty? args)
           0]
          [(not (apply dimension=? (map unit-dimension_0 args)))
           (apply error (cons "u+: cannot add units with different dimensions, given:" args))]
          [else
           (unit #f
                 (apply + (map unit-scalar_0 args))
                 (unit-dimension_0 (first args)))])))

(define u-
  (lambda args
    (cond [(empty? args)
           0]
          [(not (apply dimension=? (map unit-dimension_0 args)))
           (apply error (cons "u-: cannot subtract units with different dimensions, given:" args))]
          [else
           (unit #f
                 (apply - (map unit-scalar_0 args))
                 (unit-dimension_0 (first args)))])))

(define (uexpt u e)
  (local [(define u-scalar (unit-scalar_0 u))
          (define u-dimension (normalize-dimension (unit-dimension_0 u)))
          (define |(expt u-dimension e)|
            (cond [(integer? e)
                   (normalize-dimension (dimension-expt u-dimension e))]
                  [else
                   (cond [(dimension-product? u-dimension)
                          (define lod (dimension-product->list u-dimension))
                          (cond [(and (integer? (n* e (length lod)))
                                      (apply dimension=? lod))
                                 (normalize-dimension
                                  (list->dimension-product
                                   (build-list (n* e (length lod))
                                               (const (first lod)))))]
                                [else
                                 (normalize-dimension (dimension-expt u-dimension e))])]
                         [else
                          (normalize-dimension (dimension-expt u-dimension e))])]))]
    (unit #f
          (expt u-scalar e)
          |(expt u-dimension e)|)))



;; print-unit : (Any [OutputPort (current-output-port)] [(or/c 0 1) 0] -> Void)
;; print a unit
;; !!!
(define (print-unit expr [out (current-output-port)] [quote-depth 0])
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (cond [(and (unit? expr)
              (not (false? (unit-name_0 expr)))
              (not (equal? "" (unit-name_0 expr)))
              (not (equal? '|| (unit-name_0 expr))))
         (display (string-append
                   (if (number? quote-depth)
                       (apply string-append (build-list quote-depth (const ",")))
                       "")
                   (string-append "("(any->string (unit-name_0 expr))")"))
                  out)]
        [(and (unit? expr)
              (or (false? (unit-name_0 expr))
                  (equal? "" (unit-name_0 expr))
                  (equal? '|| (unit-name_0 expr))))
         (define found-name (find-unit-name expr))
         (cond [(not (false? found-name))
                (display (string-append
                          (if (number? quote-depth)
                              (apply string-append (build-list quote-depth (const ",")))
                              "")
                          (string-append "("(any->string found-name)")"))
                         out)]
               [(unit? expr)
                (print-unnamed-unit expr out quote-depth)]
               [else
                (print expr out quote-depth)])]
        [(unit? expr)
         (print-unnamed-unit expr out quote-depth)]
        [else
         (print expr out quote-depth)]))

;; find-unit-name : (Unit -> (or/c Symbol False))
;; find the name of the given unit from the dimension and the scalar
;; !!!
(check-expect (find-unit-name (unit #f 10 (dimension:length)))
              'meter)

(define (find-unit-name u [ms (current-measurement-system)])
  (define normalized-dimension (normalize-dimension (unit-dimension_0 u)))
  (cond [(my-equal? (dimension:dimensionless) normalized-dimension)
         (find-dimensionless-unit-name u ms)]
        [(my-equal? (dimension:length) normalized-dimension)
         (find-length-unit-name u ms)]
        [(my-equal? (dimension:mass) normalized-dimension)
         (find-mass-unit-name u ms)]
        [(my-equal? (dimension:time) normalized-dimension)
         (find-time-unit-name u ms)]
        [(my-equal? (dimension:temperature) normalized-dimension)
         (find-temperature-unit-name u ms)]
        [(find-unit-with-prefix u)
         (unit-name_0 (find-unit-with-prefix u))]
        [else
         #f]))

;; find-dimensionless-unit-name : ((unit Any Number (dimension:dimensionless)) -> (or/c Symbol False))
(define (find-dimensionless-unit-name u [ms (current-measurement-system)])
  (define (any->string thing)
    (cond [(string? thing)
           thing]
          [(symbol? thing)
           (symbol->string thing)]
          [else (~v thing)]))
  (cond [(and (unit? u)
              (not (false? (unit-name_0 u)))
              (not (equal? "" (unit-name_0 u)))
              (not (equal? '|| (unit-name_0 u))))
         (string->symbol (any->string (unit-name_0 u)))]
        [else
         (string->symbol (string-append "u* "(any->string (unit-scalar_0 u))""))]))

;; find-length-unit-name : ((unit Any Number (dimension:length)) -> (or/c Symbol False))
;; find the name of the given length unit from the scalar
;; !!!
(check-expect (find-length-unit-name (unit #f 10 (dimension:length)))
              'meter)

(define (find-length-unit-name u [ms (current-measurement-system)])
  (cond [(system=SI? ms)
         (define found (find-SI-length-unit-name u))
         (cond [found found]
               [else
                (define US-found (find-US-length-unit-name u))
                (cond [US-found US-found]
                      [else false])])]
        [(system=US? ms)
         (define found (find-US-length-unit-name u))
         (cond [found found]
               [else
                (define SI-found (find-SI-length-unit-name u))
                (cond [SI-found SI-found]
                      [else false])])]
        [(or (system=SI? (current-measurement-system))
             (system=US? (current-measurement-system)))
         (find-length-unit-name u (current-measurement-system))]
        [else
         (error "current-measurement-system: expected a valid system of units, given:" ms)]))

;; find-SI-length-unit-name : ((unit Any Number (dimension:length)) -> (or/c Symbol False))
(check-expect (find-SI-length-unit-name (unit #f 10 (dimension:length)))
              'meter)

(define (find-SI-length-unit-name u)
  (define found-unit (find-unit-with-prefix u SI-BASE-LENGTH-UNITS))
  (cond [found-unit
         (unit-name_0 found-unit)]
        [else false]))

(define (find-unit u [lou ALL-BASE-UNITS])
  (define u-dimension (normalize-dimension (unit-dimension_0 u)))
  (findf (lambda (item)
           (and (dimension=? u-dimension (unit-dimension_0 item))
                (= 1 (n/ (unit-scalar_0 u)
                         (unit-scalar_0 item)))))
         lou))

(define (find-unit-with-prefix u [lou ALL-BASE-UNITS])
  (define u-dimension (normalize-dimension (unit-dimension_0 u)))
  (define found-exact-unit
    (findf (lambda (item)
             (and (dimension=? u-dimension (unit-dimension_0 item))
                  (= 1 (n/ (unit-scalar_0 u)
                           (unit-scalar_0 item)))))
           lou))
  (cond [found-exact-unit
         found-exact-unit]
        [else
         (define found-base-unit
           (findf (lambda (item)
                    (and (dimension=? u-dimension (unit-dimension_0 item))
                         (> 0.0001 
                            (abs (- (logbase 10 (n/ (unit-scalar_0 u)
                                                    (unit-scalar_0 item)))
                                    (round (logbase 10 (n/ (unit-scalar_0 u)
                                                           (unit-scalar_0 item)))))))))
                  lou))
         (cond [found-base-unit
                (unit-rename u
                             (string->symbol
                              (string-append (symbol->string
                                              (scalar->SI-prefix
                                               (n/ (unit-scalar_0 u) 
                                                   (unit-scalar_0 found-base-unit))))
                                             (symbol->string
                                              (unit-name_0 found-base-unit)))))]
               [else false])]))

;; scalar->SI-prefix : (Number -> (or/c Symbol False))
(check-expect (scalar->SI-prefix 1)
              '||)
(check-expect (scalar->SI-prefix 1000)
              'kilo)
(check-expect (scalar->SI-prefix 1/100)
              'centi)
(check-expect (scalar->SI-prefix 1/1000)
              'milli)

(define (scalar->SI-prefix n)
  (local [(define (n=? x)
            (= n x))]
    (cond [(n=? 1) '||]
          [(n=? 10) 'deka]
          [(n=? 100) 'hecto]
          [(n=? 1000) 'kilo]
          [(n=? (10^ 6)) 'mega]
          [(n=? (10^ 9)) 'giga]
          [(n=? (10^ 12)) 'tera]
          [(n=? (10^ 15)) 'peta]
          [(n=? (10^ 18)) 'exa]
          [(n=? (10^ 21)) 'zetta]
          [(n=? (10^ 24)) 'yotta]
          [(n=? 1) '||]
          [(n=? 1/10) 'deci]
          [(n=? 1/100) 'centi]
          [(n=? 1/1000) 'milli]
          [(n=? (10^ -6)) 'micro]
          [(n=? (10^ -9)) 'nano]
          [(n=? (10^ -12)) 'pico]
          [(n=? (10^ -15)) 'femto]
          [(n=? (10^ -18)) 'atto]
          [(n=? (10^ -21)) 'zepto]
          [(n=? (10^ -24)) 'yocto]
          [(not (= n (10^ (exact-round (logbase 10 n)))))
           (scalar->SI-prefix (10^ (exact-round (logbase 10 n))))]
          [else false])))

;; find-US-length-unit-name : ((unit Any Number (dimension:length)) -> (or/c Symbol False))
;; !!!
(check-expect (find-US-length-unit-name (u* 30.48 (centimeter)))
              'foot)

(define (find-US-length-unit-name u)
  (define found-unit (find-unit-with-prefix u US-BASE-LENGTH-UNITS))
  (cond [found-unit
         (unit-name_0 found-unit)]
        [else false]))




;; find-mass-unit-name : ((unit Any Number (dimension:mass)) -> (or/c Symbol False))
;; find the name of the given mass unit from the scalar
;; !!!
(check-expect (find-mass-unit-name (unit #f 1 (dimension:mass)))
              'kilogram)

(define (find-mass-unit-name u [ms (current-measurement-system)])
  (cond [(system=SI? ms)
         (define found (find-SI-mass-unit-name u))
         (cond [found found]
               [else
                (define US-found (find-US-mass-unit-name u))
                (cond [US-found US-found]
                      [else false])])]
        [(system=US? ms)
         (define found (find-US-mass-unit-name u))
         (cond [found found]
               [else
                (define SI-found (find-SI-mass-unit-name u))
                (cond [SI-found SI-found]
                      [else false])])]
        [(or (system=SI? (current-measurement-system))
             (system=US? (current-measurement-system)))
         (find-mass-unit-name u (current-measurement-system))]
        [else
         (error "current-measurement-system: expected a valid system of units, given:" ms)]))

;; find-SI-mass-unit-name : ((unit Any Number (dimension:mass)) -> (or/c Symbol False))
(check-expect (find-SI-mass-unit-name (unit #f 1 (dimension:mass)))
              'kilogram)

(define (find-SI-mass-unit-name u)
  (define found-unit (find-unit-with-prefix u SI-BASE-MASS-UNITS))
  (cond [found-unit
         (unit-name_0 found-unit)]
        [else false]))

;; find-US-mass-unit-name : ((unit Any Number (dimension:mass)) -> (or/c Symbol False))
;; !!!
(check-expect (find-US-mass-unit-name (u/ (kilogram) 2.205))
              'pound-mass)

(define (find-US-mass-unit-name u)
  (define found-unit (find-unit-with-prefix u US-BASE-MASS-UNITS))
  (cond [found-unit
         (unit-name_0 found-unit)]
        [else false]))

;; find-time-unit-name : ((unit Any Number (dimension:time)) -> (or/c Symbol False))
;; find the name of the given time unit from the scalar
;; !!!
(check-expect (find-time-unit-name (unit #f 1 (dimension:time)))
              'second)

(define (find-time-unit-name u [ms (current-measurement-system)])
  (define found-unit (find-unit-with-prefix u SI-BASE-TIME-UNITS))
  (cond [found-unit
         (unit-name_0 found-unit)]
        [else false]))

;; find-temperature-unit-name : ((unit Any Number (dimension:temperature)) -> (or/c Symbol False))
;; find the name of the given temperature unit from the scalar
;; !!!
(check-expect (find-temperature-unit-name (unit #f 1 (dimension:temperature)))
              'kelvin)

(define (find-temperature-unit-name u [ms (current-measurement-system)])
  (define (scalar=? x)
    (=~ x (unit-scalar_0 u) 0.01))
  (cond [(scalar=? (unit-scalar_0 (kelvin))) 'kelvin]
        [(scalar=? (unit-scalar_0 (rankine))) 'rankine]
        [(> 0.0001 
            (abs (- (logbase 10 (unit-scalar_0 u))
                    (round (logbase 10 (unit-scalar_0 u))))))
         (string->symbol
          (string-append (symbol->string
                          (scalar->SI-prefix
                           (unit-scalar_0 u)))
                         "kelvin"))]
        [(> 0.0001 
            (abs (- (logbase 10 (n* 9/5 (unit-scalar_0 u)))
                    (round (logbase 10 (n* 9/5 (unit-scalar_0 u)))))))
         (string->symbol
          (string-append (symbol->string
                          (scalar->SI-prefix
                           (n* 9/5 (unit-scalar_0 u))))
                         "rankine"))]
        [else #f]))



;; print-unnamed-unit : (Any [OutputPort (current-output-port)] [(or/c 0 1) 0] -> Void)
;; print a unit like a normal struct
(define (print-unnamed-unit expr [out (current-output-port)] [quote-depth 0])
  (cond [(unit? expr)
         (display (string-append
                   (if (number? quote-depth)
                       (apply string-append (build-list quote-depth (const ",")))
                       "")
                   (string-append "(unit "(~v(unit-name_0 expr))" "(~v(unit-scalar_0 expr))" "(~v(unit-dimension_0 expr))")"))
                  out)]
        [else
         (print expr out quote-depth)]))
















(struct number-with-unit (number unit)
  #:transparent
  #:methods gen:custom-write
  [(define (write-proc expr out quote-depth)
     (cond [(or (equal? 0 quote-depth)
                (equal? 1 quote-depth))
            (print-number-with-unit expr out quote-depth)]
           [else
            (print-number-with-unit expr out)]))]
  )
(define (number-with-unit-number_0 a)
  (number-with-unit-number (any->number-with-unit a)))
(define (number-with-unit-unit_0 a)
  (number-with-unit-unit (any->number-with-unit a)))

(define (nwu-number a) 
  (number-with-unit-number (any->number-with-unit a)))
(define (nwu-unit a)
  (number-with-unit-unit (any->number-with-unit a)))

(define (nwu-unit-name a)
  (unit-name_0 (nwu-unit a)))
(define (nwu-unit-scalar a)
  (unit-scalar_0 (nwu-unit a)))
(define (nwu-unit-dimension a)
  (unit-dimension_0 (nwu-unit a)))

(define (nwu-dimension a)
  (unit-dimension_0 (nwu-unit a)))

(define (vector-with-unit? a)
  (and (number-with-unit? a)
       (vector? (nwu-number a))))
(define (vector-without-units? a)
  (and (vector? a)
       (andmap number?
               (vector->list a))))

(define (any->number-with-unit expr)
  (cond [(dimension? expr)
         (number-with-unit 1 
                           (unit #f
                                 1
                                 expr))]
        [(unit? expr)
         (number-with-unit 1
                           expr)]
        [(number-with-unit? expr)
         (cond [(number-with-unit? (number-with-unit-number expr))
                (any->number-with-unit
                 (number-with-unit (number-with-unit-number (number-with-unit-number expr))
                                   (u* (number-with-unit-unit expr)
                                       (number-with-unit-unit (number-with-unit-number expr)))))]
               [else
                expr])]
        [(number-without-unit? expr)
         (number-with-unit expr
                           (unit #f
                                 1
                                 (dimension:dimensionless)))]
        [(and (vector? expr)
              (< 1 (vector-length expr))
              (apply dimension=?
                     (map nwu-dimension
                          (vector->list expr))))
         (define v-unit
           (nwu-unit (vector-ref expr 0)))
         (define v-numbers
           (vector-map (lambda (item)
                         (nwu-number (convert item v-unit)))
                       expr))
         (when (and (vector? v-numbers)
                    (not (andmap number-without-unit? (vector->list v-numbers))))
           (displayln (string-append "warning: "
                                     "vector-with-unit: nwu-number may not be a (vectorof number-without-unit?), "
                                     "in: "(~v v-numbers))))
         (number-with-unit v-numbers 
                           v-unit)]
        [else
         (when (not (or (number? expr)
                        (vector? expr)))
           (displayln (string-append "warning: "
                                     "number-with-unit: nwu-number may not be a number or a vector, "
                                     "in: "(~v expr))))
         (when (and (vector? expr)
                    (not (andmap number-without-unit? (vector->list expr))))
           (displayln (string-append "warning: "
                                     "vector-with-unit: nwu-number may not be a (vectorof number-without-unit?), "
                                     "in: "(~v expr))))
         (number-with-unit expr 
                           (unit #f
                                 1
                                 (dimension:dimensionless)))]))

;; convert : (case->
;;             (NumberWithUnit Unit -> NumberWithUnit)
;;             (Number    Unit Unit -> NumberWithUnit))
;; convert the number with the unit to the other unit
;;  - if it's given 2 args (a number-with-unit and a unit), then it converts the number-with-unit to the given unit
;;  - if it's given 3 args (a number, an initial unit, and a final unit), then it converts the number from the initial unit to the final unit
(check-expect (convert (number-with-unit 1 (meter)) (centimeter))
              (number-with-unit 100 (centimeter)))
(check-expect (convert 1 (meter) (centimeter))
              (number-with-unit 100 (centimeter)))

(define convert
  (case-lambda
    [(num-with-u1 u2)
     (cond [(not (dimension=? (nwu-dimension num-with-u1) (unit-dimension_0 u2)))
            (error "convert: cannot convert between dimensions, given:" num-with-u1 u2)]
           [else
            (define num (nwu-number num-with-u1))
            (define u1 (nwu-unit num-with-u1))
            (number-with-unit (n* num
                                  (n/ (unit-scalar_0 u1)
                                      (unit-scalar_0 u2)))
                              u2)])]
    [(num u1 u2)
     (convert (number-with-unit num u1) u2)]))



;; nwu=
;; like =, but for numbers with units, without requiring that they be numbers with units
(check-expect (nwu= (number-with-unit 1    (meter))
                    (number-with-unit 100  (centimeter))
                    (number-with-unit 1000 (millimeter)))
              true)

(define nwu=
  (lambda args
    (cond [(empty? args)
           (error "nwu=: expects 2 or more arguments, given 0")]
          [else
           (and (apply dimension=? (map nwu-dimension args))
                (local [(define u (nwu-unit (first args)))
                        (define converted-args
                          (for/list ([arg args])
                            (convert arg u)))]
                  (and (or (>= 1 (length converted-args))
                           (apply = (map nwu-number converted-args)))
                       (apply unit=? (map nwu-unit converted-args)))))])))

;; nwu*
;; like *, but for numbers with units, without requiring that they be numbers with units
(check-expect (my-equal? (nwu* 2 (newton) 3 (meter))
                         (number-with-unit 6 (unit-rename (joule) #f)))
              true)

(define nwu*
  (lambda args
    (number-with-unit (apply n* (map nwu-number args))
                      (apply u* (map nwu-unit args)))))

;; nwu/
;; like /, but for numbers with units, without requiring that they be numbers with units
(check-expect (my-equal? (nwu/ (number-with-unit 6 (joule))
                               (number-with-unit 2 (meter)))
                         (number-with-unit 3 (unit-rename (newton) #f)))
              true)

(define nwu/
  (lambda args
    (number-with-unit (apply n/ (map nwu-number args))
                      (apply u/ (map nwu-unit args)))))

;; nwu+
;; like +, but for numbers with units, without requiring that they be numbers with units, but requiring that they have the same dimension
(check-expect (nwu+ (number-with-unit 2 (meter))
                    (number-with-unit 50 (centimeter)))
              (number-with-unit 2.5 (meter)))

(define nwu+
  (lambda args
    (cond [(empty? args)
           0]
          [(not (apply dimension=? (map nwu-dimension args)))
           (apply error (cons "nwu+: cannot add numbers with different dimensions, given:" args))]
          [(apply unit=? (map nwu-unit args))
           (number-with-unit (apply + (map nwu-number args))
                             (nwu-unit (first args)))]
          [else
           (apply nwu+
                  (map (lambda (arg)
                         (convert arg (nwu-unit (first args))))
                       args))])))

;; nwu-
;; like -, but for numbers with units, without requiring that they be numbers with units, but requiring that they have the same dimension
(check-expect (nwu- (number-with-unit 2 (meter))
                    (number-with-unit 50 (centimeter)))
              (number-with-unit 1.5 (meter)))

(define nwu-
  (lambda args
    (cond [(empty? args)
           0]
          [(not (apply dimension=? (map nwu-dimension args)))
           (apply error (cons "nwu-: cannot subtract numbers with different dimensions, given:" args))]
          [(apply unit=? (map nwu-unit args))
           (number-with-unit (apply - (map nwu-number args))
                             (nwu-unit (first args)))]
          [else
           (apply nwu-
                  (map (lambda (arg)
                         (convert arg (nwu-unit (first args))))
                       args))])))

;; nwuexpt
;; like expt, but for numbers with units, without requiring that they be numbers with units

(define (nwuexpt nwu e)
  (number-with-unit (expt (nwu-number nwu) e)
                    (uexpt (nwu-unit nwu) e)))

(define (nwusqr nwu)
  (number-with-unit (sqr (nwu-number nwu))
                    (u* (nwu-unit nwu)
                        (nwu-unit nwu))))

(define (nwusqrt nwu)
  (number-with-unit (sqrt (nwu-number nwu))
                    (uexpt (nwu-unit nwu) 1/2)))





;; print-number-with-unit : (Any [OutputPort (current-output-port)] [(or/c 0 1) 0] -> Void)
;; print a number with a unit
;; !!!
(define (print-number-with-unit expr [out (current-output-port)] [quote-depth 0])
  (cond [(angle? expr)
         (print-angle expr out quote-depth)]
        [(number? expr)
         (print expr out quote-depth)]
        [(and (number-with-unit? expr)
              (= 1 (nwu-unit-scalar expr))
              (dimensionless? (nwu-dimension expr)))
         (print (nwu-number expr)
                out quote-depth)]
        [(number-with-unit? expr)
         (display (string-append
                   (if (number? quote-depth)
                       (apply string-append (build-list quote-depth (const ",")))
                       "")
                   (string-append "(* "(~v(nwu-number expr))" "(~v(nwu-unit expr))")"))
                  out)]
        [else
         (print expr out quote-depth)]))



;; print-angle : (Any [OutputPort (current-output-port)] [(or/c 0 1) 0] -> Void)
;; print an angle
(define (print-angle expr [out (current-output-port)] [quote-depth 0])
  (cond [(and (number-with-unit? expr)
              (dimensionless? (nwu-dimension expr)))
         (cond [(unit=? (nwu-unit expr) (radian))
                (define as (current-angle-measurement-system))
                (cond [(angle-system=radians? as)
                       (print-angle (nwu-number expr) out quote-depth)]
                      [(angle-system=radians-with-pi? as)
                       (print-angle (nwu-number expr) out quote-depth)]
                      [(angle-system=radians-with-2pi? as)
                       (print-angle (nwu-number expr) out quote-depth)]
                      [(angle-system=radians-with-tau? as)
                       (print-angle (nwu-number expr) out quote-depth)]
                      [(angle-system=radians-with-eta? as)
                       (print-angle (nwu-number expr) out quote-depth)]
                      [else
                       (print (nwu-number expr) out quote-depth)])]
               [(unit=? (nwu-unit expr) (turn))
                (display (string-append (~v(nwu-number expr))"*turns")
                         out)]
               [(unit=? (nwu-unit expr) (degree))
                (display (string-append (~v(nwu-number expr))"°")
                         out)]
               [else
                (print expr out quote-depth)])]
        [(number? expr)
         (define as (current-angle-measurement-system))
         (cond [(angle-system=radians? as)
                (print expr out quote-depth)]
               [(angle-system=radians-with-pi? as)
                (display (string-append (~v(n/ expr really-close-to-pi))"*pi")
                         out)]
               [(angle-system=radians-with-2pi? as)
                (display (string-append (~v(n/ expr really-close-to-2pi))"*2pi")
                         out)]
               [(angle-system=radians-with-tau? as)
                (display (string-append (~v(n/ expr really-close-to-tau))"*tau")
                         out)]
               [(angle-system=radians-with-eta? as)
                (display (string-append (~v(n/ expr really-close-to-eta))"*eta")
                         out)]
               [(angle-system=turns? as)
                (display (string-append (~v(n/ expr really-close-to-tau))"*turns")
                         out)]
               [(angle-system=degrees? as)
                (display (string-append (~v(n* expr (/ 360 really-close-to-tau)))"°")
                         out)]
               [else 
                (print expr out quote-depth)])]
        [else
         (print expr out quote-depth)]))













;; SI prefix functions:

(define (kilo u)
  (unit-rename (u* 1000 u)
               (string->symbol
                (string-append "kilo "(~v u)""))))
(define (centi u)
  (unit-rename (u/ u 100)
               (string->symbol
                (string-append "centi "(~v u)""))))
(define (milli u)
  (unit-rename (u/ u 1000)
               (string->symbol
                (string-append "milli "(~v u)""))))
(define (micro u)
  (unit-rename (u/ u (10^ 6))
               (string->symbol
                (string-append "micro "(~v u)""))))
(define (nano u)
  (unit-rename (u/ u (10^ 9))
               (string->symbol
                (string-append "nano "(~v u)""))))

;; SI units:

(define-unit (meter)
  (unit 'meter 10 (dimension:length)))
(define-unit (centimeter)
  (u/ (meter)
      100))
(define-unit (millimeter)
  (u/ (meter)
      1000))
(define-unit (kilometer)
  (u* 1000 (meter)))
(define-unit (decimeter)
  (unit 'decimeter 1 (dimension:length)))
(define SI-BASE-LENGTH-UNITS
  (list (meter)))

(define-unit (kilogram)
  (unit 'kilogram 1 (dimension:mass)))
(define-unit (gram)
  (u/ (kilogram)
      1000))
(define SI-BASE-MASS-UNITS
  (list (gram)))

(define-unit (second)
  (unit 'second 1 (dimension:time)))
(define-unit (minute)
  (u* 60 (second)))
(define-unit (hour)
  (u* 60 (minute)))
(define-unit (day)
  (u* 24 (hour)))
(define-unit (week)
  (u* 7 (day)))
(define-unit (common-year)
  (u* 365 (day)))
(define-unit (leap-year)
  (u* 366 (day)))
(define-unit (average-year)
  (u* #e365.25 (day)))
(define-unit (average-month)
  (u/ (average-year) 12))
(define-unit (average-decade)
  (u* 10 (average-year)))
(define-unit (century)
  (u* 100 (average-year)))
(define-unit (average-century)
  (u* 100 (average-year)))
(define-unit (millisecond)
  (u/ (second) 1000))
(define-unit (microsecond)
  (u/ (second) (10^ 6)))
(define-unit (nanosecond)
  (u/ (second) (10^ 9)))
(define SI-BASE-TIME-UNITS
  (list (second)
        (minute)
        (hour)
        (day)
        (week)
        (average-year)
        (average-decade)
        (century)))

(define-unit (kelvin)
  (unit 'kelvin 1 (dimension:temperature)))
(define °K (kelvin))
(define SI-BASE-TEMPERATURE-UNITS
  (list (kelvin)))

(define-unit (radian)
  (unit 'radian 1 (dimension:dimensionless)))
(define-unit (turn)
  (u* really-close-to-tau (radian)))
(define-unit (revolution)
  (u* really-close-to-tau (radian)))
(define-unit (degree)
  (u/ (turn) 360))
(define ° (degree))
(define (angle? expr)
  (define expr-unit
    (nwu-unit expr))
  (define (expr-unit=? u)
    (named-unit=? expr-unit u))
  (ormap expr-unit=?
         (list (radian)
               (turn)
               (revolution)
               (degree))))
(define SI-BASE-ANGLE-UNITS
  (list (radian)
        (turn)
        (revolution)
        (degree)))

(define-unit (square-meter)
  (u* (meter) (meter)))
(define-unit (square-centimeter)
  (u* (centimeter) (centimeter)))
(define SI-BASE-AREA-UNITS
  (list (square-meter)
        (square-centimeter)))

(define-unit (cubic-meter)
  (u* (meter) (meter) (meter)))
(define-unit (cubic-centimeter)
  (u* (centimeter) (centimeter) (centimeter)))
(define-unit (liter)
  (u* (decimeter) (decimeter) (decimeter)))
(define-unit (milliliter)
  (u* (centimeter) (centimeter) (centimeter)))
(define SI-BASE-VOLUME-UNITS
  (list (liter)
        (cubic-meter)
        (cubic-centimeter)))

(define-unit (gram-per-cubic-centimeter)
  (u/ (gram)
      (cubic-centimeter)))
(define-unit (kilogram-per-cubic-meter)
  (u/ (kilogram)
      (cubic-meter)))
(define SI-BASE-DENSITY-UNITS
  (list (gram-per-cubic-centimeter)
        (kilogram-per-cubic-meter)))

(define-unit (meter-per-second)
  (u/ (meter)
      (second)))
(define-unit (kilometer-per-hour)
  (u/ (kilometer)
      (hour)))
(define SI-BASE-VELOCITY-UNITS
  (list (meter-per-second)
        (kilometer-per-hour)))

(define-unit (meter-per-second-squared)
  (u/ (meter)
      (second)
      (second)))
(define SI-BASE-ACCELERATION-UNITS
  (list (meter-per-second-squared)))

(define-unit (newton)
  (u* (kilogram) (meter-per-second-squared)))
(define SI-BASE-FORCE-UNITS
  (list (newton)))

(define-unit (kilogram-meter-per-second)
  (u* (kilogram) (meter-per-second)))
(define-unit (newton-second)
  (u* (newton) (second)))
(define SI-BASE-MOMENTUM-UNITS
  (list (kilogram-meter-per-second)
        (newton-second)))

(define-unit (newton-meter)
  (u* (newton) (meter)))
(define-unit (joule)
  (u* (newton) (meter)))
(define-unit (calorie)
  (u* #e4.184 (joule)))
(define SI-BASE-ENERGY-UNITS
  (list (joule)
        (calorie)))
(define SI-BASE-WORK-UNITS
  (list (newton-meter)
        (joule)
        (calorie)))

(define-unit (watt)
  (u/ (joule)
      (second)))
(define-unit (kilowatt)
  (u* 1000 (watt)))
(define SI-BASE-POWER-UNITS
  (list (watt)))

(define-unit (pascal)
  (u/ (newton)
      (square-meter)))
(define SI-BASE-PRESSURE-UNITS
  (list (pascal)))

(define SI-BASE-UNITS
  (append SI-BASE-LENGTH-UNITS
          SI-BASE-MASS-UNITS
          SI-BASE-TIME-UNITS
          SI-BASE-TEMPERATURE-UNITS
          SI-BASE-ANGLE-UNITS
          SI-BASE-AREA-UNITS
          SI-BASE-VOLUME-UNITS
          SI-BASE-DENSITY-UNITS
          SI-BASE-VELOCITY-UNITS
          SI-BASE-ACCELERATION-UNITS
          SI-BASE-FORCE-UNITS
          SI-BASE-MOMENTUM-UNITS
          SI-BASE-ENERGY-UNITS
          SI-BASE-POWER-UNITS
          SI-BASE-PRESSURE-UNITS))



;; US units:

(define-unit (foot)
  (u* #e30.48 (centimeter)))
(define-unit (inch)
  (u/ (foot) 12))
(define-unit (yard)
  (u* 3 (foot)))
(define-unit (mile)
  (u* 5280 (foot)))
(define US-BASE-LENGTH-UNITS
  (list (foot)
        (inch)
        (yard)
        (mile)))

(define-unit (pound-mass)
  (u* #e0.45359237 (kilogram)))
(define-unit (ounce-mass)
  (u/ (pound-mass) 16))
(define-unit (ton)
  (u* 2000 (pound-mass)))
(define US-BASE-MASS-UNITS
  (list (pound-mass)
        (ounce-mass)
        (ton)))

#;(;these were already defined under SI units:
   (define-unit (second)
     (unit 'second 1 (dimension:time)))
   (define-unit (minute)
     (u* 60 (second)))
   (define-unit (hour)
     (u* 60 (minute)))
   (define-unit (day)
     (u* 24 (hour)))
   (define-unit (week)
     (u* 7 (day)))
   (define-unit (year)
     (u* 365 (day)))
   (define-unit (decade)
     (u* 10 (year)))
   (define-unit (century)
     (u* 100 (year)))
   )
(define US-BASE-TIME-UNITS 
  SI-BASE-TIME-UNITS)

(define-unit (rankine)
  (u* 5/9 (kelvin)))
(define US-BASE-TEMPERATURE-UNITS
  (list (rankine)))

#;(;these were already defined under SI units:
   (define-unit (radian)
     (unit 'radian 1 (dimension:dimensionless)))
   (define-unit (turn)
     (u* tau (radian)))
   (define-unit (revolution)
     (u* tau (radian)))
   (define-unit (degree)
     (u/ (turn) 360))
   )
(define US-BASE-ANGLE-UNITS
  SI-BASE-ANGLE-UNITS)

(define-unit (square-foot)
  (u* (foot) (foot)))
(define-unit (square-inch)
  (u* (inch) (inch)))
(define-unit (square-mile)
  (u* (mile) (mile)))
(define-unit (acre)
  (u* 43560 (square-foot)))
(define US-BASE-AREA-UNITS
  (list (square-foot)
        (square-inch)
        (square-mile)
        (acre)))

(define-unit (cubic-foot)
  (u* (foot) (foot) (foot)))
(define-unit (cubic-inch)
  (u* (inch) (inch) (inch)))
(define-unit (gallon)
  (u* 231 (cubic-inch)))
(define-unit (quart)
  (u/ (gallon) 4))
(define-unit (pint)
  (u/ (quart) 2))
(define-unit (cup)
  (u/ (pint) 2))
(define-unit (fluid-ounce)
  (u/ (cup) 8))
(define US-BASE-VOLUME-UNITS
  (list (cubic-foot)
        (cubic-inch)
        (gallon)
        (quart)
        (pint)
        (cup)
        (fluid-ounce)))

(define US-BASE-DENSITY-UNITS
  empty)

(define-unit (mile-per-hour)
  (u/ (mile)
      (hour)))
(define-unit (foot-per-second)
  (u/ (foot)
      (second)))
(define US-BASE-VELOCITY-UNITS
  (list (mile-per-hour)
        (foot-per-second)))

(define-unit (foot-per-second-squared)
  (u/ (foot)
      (second)
      (second)))
(define US-BASE-ACCELERATION-UNITS
  (list (foot-per-second-squared)))

(define-unit (pound-force)
  (u* (u* #e9.80665 (meter-per-second-squared))
      (pound-mass)))
(define US-BASE-FORCE-UNITS
  (list (pound-force)))

(define US-BASE-MOMENTUM-UNITS
  empty)

(define-unit (foot-pound-force)
  (u* (foot) (pound-force)))
(define-unit (british-thermal-unit)
  (u* #e1055.05585262 (joule)))
(define-unit (kilowatt-hour)
  (u* (kilowatt) (hour)))
(define US-BASE-ENERGY-UNITS
  (list (foot-pound-force)
        (british-thermal-unit)
        (kilowatt-hour)))
(define US-BASE-WORK-UNITS
  (list (foot-pound-force)
        (british-thermal-unit)
        (kilowatt-hour)))

(define-unit (horsepower)
  (u* #e746 (watt)))
(define-unit (british-thermal-unit-per-hour)
  (u/ (british-thermal-unit) (hour)))
(define US-BASE-POWER-UNITS
  (list (horsepower)
        (watt)
        (kilowatt)
        (british-thermal-unit-per-hour)))

(define-unit (pound-per-square-inch)
  (u/ (pound-force)
      (square-inch)))
(define-unit (atmosphere)
  (u* #e101325 (pascal)))
(define-unit (bar)
  (u* #e100000 (pascal)))
(define-unit (millibar)
  (u/ (bar) 1000))
(define US-BASE-PRESSURE-UNITS
  (list (pound-per-square-inch)
        (atmosphere)
        (bar)
        (millibar)))

(define US-BASE-UNITS
  (append US-BASE-LENGTH-UNITS
          US-BASE-MASS-UNITS
          US-BASE-TIME-UNITS
          US-BASE-TEMPERATURE-UNITS
          US-BASE-ANGLE-UNITS
          US-BASE-AREA-UNITS
          US-BASE-VOLUME-UNITS
          US-BASE-DENSITY-UNITS
          US-BASE-VELOCITY-UNITS
          US-BASE-ACCELERATION-UNITS
          US-BASE-FORCE-UNITS
          US-BASE-MOMENTUM-UNITS
          US-BASE-ENERGY-UNITS
          US-BASE-POWER-UNITS
          US-BASE-PRESSURE-UNITS))



(define ALL-BASE-UNITS
  (remove-duplicates
   (append SI-BASE-UNITS
           US-BASE-UNITS)))





;; Some Physical Constants:

(define g  ; the acceleration due to gravity on earth
  (number-with-unit #e9.80665
                    (meter-per-second-squared)))

(define G  ; Newton's universal gravitational constant, 
  #;()    #; (for use in F = (* G (/ (* m-1 m-2)
                                     (sqr d))))
  (number-with-unit (* #i6.7384 (10^ -11))
                    (u* (newton)
                        (u/ (u* (meter) (meter))
                            (u* (kilogram) (kilogram))))))

(define c  ; the speed of light in a vacuum
  (number-with-unit #e299792458
                    (meter-per-second)))




















;; Some Physics Formulas:

(define (kinetic-energy #:m [m #f] #:v [v #f] 
                        #:I [I #f] #:w [w #f])
  (cond [(and m v I w)
         (nwu+ (kinetic-energy #:m m #:v v)
               (kinetic-energy #:I I #:w w))]
        [(and m v)
         (cond [(number-without-unit? (nwu-number v))
                (nwu* 1/2 m (nwusqr v))]
               [(vector-without-units? (nwu-number v))
                (nwu* 1/2 m 
                      (number-with-unit (vsqr   (nwu-number v))
                                        (nwusqr (nwu-unit v))))]
               [else
                (error "kinetic-energy: not a proper velocity, given:" v)])]
        [(and I w)
         (cond [(number-without-unit? (nwu-number w))
                (nwu* 1/2 I (sqr w))]
               [(vector-without-units? (nwu-number v))
                (nwu* 1/2 I 
                      (number-with-unit (vsqr   (nwu-number v))
                                        (nwusqr (nwu-unit w))))]
               [else
                (error "kinetic-energy: not a proper angular velocity, given:" w)])]
        [else
         (define-syntax-rule 
           (cond-string-append clause ...)
           (string-append (cond clause 
                                [else ""])
                          ...))
         (error (cond-string-append [#t "kinetic-energy: not enough information, given: "]
                                    [m (string-append "#:m "(~v m)" ")]
                                    [v (string-append "#:v "(~v v)" ")]
                                    [I (string-append "#:I "(~v I)" ")]
                                    [w (string-append "#:w "(~v w)" ")]
                                    [(and (not m) (not v)
                                          (not I) (not w))
                                     (string-append "nothing")]
                                    ))]))






(test)